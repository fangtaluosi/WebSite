<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust learning notes</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="1_env_config/env_config.html"><strong aria-hidden="true">1.</strong> Rust环境配置(Windows)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="1_env_config/rust-analyer.html"><strong aria-hidden="true">1.1.</strong> rust-analyer</a></li></ol></li><li class="chapter-item expanded "><a href="2_quickly_start/quickly_start.html"><strong aria-hidden="true">2.</strong> 快速开始</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="2_quickly_start/hello_rust.html"><strong aria-hidden="true">2.1.</strong> Hello Rust</a></li><li class="chapter-item expanded "><a href="2_quickly_start/hello_cargo.html"><strong aria-hidden="true">2.2.</strong> Hello Cargo</a></li><li class="chapter-item expanded "><a href="2_quickly_start/var_const_type.html"><strong aria-hidden="true">2.3.</strong> 变量、常量与原生类型</a></li><li class="chapter-item expanded "><a href="2_quickly_start/array_vec_string.html"><strong aria-hidden="true">2.4.</strong> 数组、动态数组与字符串</a></li><li class="chapter-item expanded "><a href="2_quickly_start/struct_emun.html"><strong aria-hidden="true">2.5.</strong> 结构体与枚举</a></li><li class="chapter-item expanded "><a href="2_quickly_start/control_flow.html"><strong aria-hidden="true">2.6.</strong> 控制流</a></li><li class="chapter-item expanded "><a href="2_quickly_start/fn_impl.html"><strong aria-hidden="true">2.7.</strong> 函数与方法</a></li><li class="chapter-item expanded "><a href="2_quickly_start/trait.html"><strong aria-hidden="true">2.8.</strong> 特性、泛型与多态</a></li><li class="chapter-item expanded "><a href="2_quickly_start/doc.html"><strong aria-hidden="true">2.9.</strong> 注释与文档</a></li><li class="chapter-item expanded "><a href="2_quickly_start/io.html"><strong aria-hidden="true">2.10.</strong> 输入输出流</a></li></ol></li><li class="chapter-item expanded "><a href="3_basic_program_struct/basic_program_struct.html"><strong aria-hidden="true">3.</strong> 基本程序结构</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3_basic_program_struct/comment.html"><strong aria-hidden="true">3.1.</strong> 注释</a></li><li class="chapter-item expanded "><a href="3_basic_program_struct/conditional_branch.html"><strong aria-hidden="true">3.2.</strong> 条件分支语句</a></li><li class="chapter-item expanded "><a href="3_basic_program_struct/circulate.html"><strong aria-hidden="true">3.3.</strong> 循环语句</a></li></ol></li><li class="chapter-item expanded "><a href="4_type_operator_string/type_operator_string.html"><strong aria-hidden="true">4.</strong> 类型、运算符与字符串</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="4_type_operator_string/native_type.html"><strong aria-hidden="true">4.1.</strong> 原生类型</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Rust learning notes</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="rust环境配置"><a class="header" href="#rust环境配置">Rust环境配置</a></h1>
<h2 id="安装cbuild-tool"><a class="header" href="#安装cbuild-tool">安装C++build tool</a></h2>
<h3 id="安装visualstudio"><a class="header" href="#安装visualstudio">安装VisualStudio</a></h3>
<p>在单个组件选项卡中安装如下组件
<img src="1_env_config/../../image/1.png" alt="vs" /></p>
<h2 id="安装rust"><a class="header" href="#安装rust">安装Rust</a></h2>
<p><strong>Rust</strong> 中文官网 <a href="https://www.rust-lang.org/zh-CN">Rust-lang</a> 下载 rustup-init.exe</p>
<h3 id="配置环境变量"><a class="header" href="#配置环境变量">配置环境变量</a></h3>
<p>打开系统环境变量
在环境变量里新建 <code>RUSTUP_HOME</code> ，对应 <strong>rustup</strong> 的安装目录在环境变量里配置，以下是我的配置</p>
<p><img src="1_env_config/../../image/2.png" alt="rustup home" /></p>
<p>新建<code>CARGO_HOME</code> ，对应 <strong>cargo</strong> 的安装目录</p>
<p><img src="1_env_config/../../image/3.png" alt="cargo home" /></p>
<p>因为Rust的服务器在国外，安装速度较慢，所以我们可以考虑使用镜像源
新建 <code>RUSTUP_DIST_SERVER</code>，其中的内容为 <code>https://mirrors.ustc.edu.cn/rust-static</code></p>
<p><img src="1_env_config/../../image/4.png" alt="rustup" /></p>
<p>新建 <code>RUSTUP_UPDATE_ROOT</code>，其中的内容为<code>https://mirrors.ustc.edu.cn/rust-static/rustup</code></p>
<p><img src="1_env_config/../../image/5.png" alt="rustup" /></p>
<h3 id="安装-rust"><a class="header" href="#安装-rust">安装 Rust</a></h3>
<p>运行 rustup-init.exe</p>
<p><img src="1_env_config/../../image/6.png" alt="rustup-init" /></p>
<p>输入 1 后回车即可</p>
<p>完成安装</p>
<p><img src="1_env_config/../../image/7.png" alt="rustup-init" /></p>
<h3 id="验证安装"><a class="header" href="#验证安装">验证安装</a></h3>
<p><img src="1_env_config/../../image/8.png" alt="rustup-init" /></p>
<h2 id="配置开发环境"><a class="header" href="#配置开发环境">配置开发环境</a></h2>
<h3 id="安装编辑器"><a class="header" href="#安装编辑器">安装编辑器</a></h3>
<p>这里推荐<a href="https://code.visualstudio.com/">vscode</a></p>
<h3 id="安装插件"><a class="header" href="#安装插件">安装插件</a></h3>
<h4 id="rust官方插件"><a class="header" href="#rust官方插件">Rust官方插件</a></h4>
<p><img src="1_env_config/../../image/9.png" alt="rust" /></p>
<p>如果您喜欢折腾，我更推荐这一款 <a href="1_env_config/./rust-analyer.html">rust-analyer</a></p>
<h4 id="中文界面插件"><a class="header" href="#中文界面插件">中文界面插件</a></h4>
<p><img src="1_env_config/../../image/10.png" alt="Chinese" /></p>
<h4 id="ai代码提示插件"><a class="header" href="#ai代码提示插件">AI代码提示插件</a></h4>
<p><img src="1_env_config/../../image/11.png" alt="ai" /></p>
<h4 id="crate管理插件"><a class="header" href="#crate管理插件">crate管理插件</a></h4>
<p><img src="1_env_config/../../image/12.png" alt="crates" /></p>
<h4 id="toml支持插件"><a class="header" href="#toml支持插件">TOML支持插件</a></h4>
<p><img src="1_env_config/../../image/13.png" alt="toml" /></p>
<h2 id="至此rust环境配置完毕"><a class="header" href="#至此rust环境配置完毕">至此rust环境配置完毕</a></h2>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="rust-analyer"><a class="header" href="#rust-analyer">rust-analyer</a></h1>
<p><img src="1_env_config/../../image/14.png" alt="rust-analyer" /></p>
<h2 id="简介"><a class="header" href="#简介">简介</a></h2>
<p>rust-analyer(简称RA)是由Rust社区维护的RLS 2.0(自封的)，但它以后将会并入或是说取代官方的RLS。RLS有的它更好，RLS没有的它还有，甚至可以提示第三方库的代码，所以更推荐安装这一个。更多内容可以浏览它官网的<a href="https://rust-analyzer.github.io/manual.html">用户手册</a></p>
<h2 id="安装"><a class="header" href="#安装">安装</a></h2>
<p>安装插件之后，将会自动下载它服务器的二进制文件，点击下载即可</p>
<p>要使用它，需要明确何为<strong>cargo workspace</strong>，RA会检查根目录下的Cargo.toml文件，文件不像一般的cargo项目，在这里您需要指定workspace</p>
<p>在vscode中新建文件夹，在该文件夹下新建Cargo.toml文件，在文件内写入</p>
<pre><code class="language-toml">[workspace]
members = []
</code></pre>
<p>如果要新建项目，现在该文件的members后的方括号内写入<code>&quot;项目名&quot;，</code> ，再在顶目录运行<code>cargo new 项目名</code>，新项目内将不会生成<code>Cargo.lock</code>文件和<code>targe</code>文件夹，而是与顶层目录共用这些文件，可以避免重复的编译</p>
<p>关于workspace，会在后续章节讲解</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="快速开始"><a class="header" href="#快速开始">快速开始</a></h1>
<p>上一章中，我们已经安装好了Rust，配置好了编辑器，现在可以开始写代码了。 本章的目的是让您迅速上手Rust语言，所以您不必理解全部内容，本章所有知识点均会在以后的章节再次详细讲解</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="hello-rust"><a class="header" href="#hello-rust">Hello Rust</a></h1>
<h2 id="helloworld"><a class="header" href="#helloworld">HelloWorld</a></h2>
<p>学习一门语言的传统都是打印 <strong>Hello World</strong> 下面我们创建一下 Rust 的 Helloworld 程序</p>
<h2 id="创建一个rust文件"><a class="header" href="#创建一个rust文件">创建一个Rust文件</a></h2>
<p>打开 <strong>vscode</strong>，新建一个文件夹用于存放我们所有的代码，在这个文件夹下新建 <em>hello_world</em> 文件夹，在里面新建一个 <strong>main.rs</strong>文件（Rust的习惯后缀名为 <strong>.rs</strong>虽然别的后缀名也能通过编译）</p>
<p>关于文件命名，Rust采用<strong>蛇形命名法</strong>，如果名字有多个单词，<strong>无需</strong>有大写字母，而是采用<code>_</code>来分隔每一个单词，如<strong>hello_world.rs</strong>，尽量避免使用ASCII字符以外的字符，不要以数字开头</p>
<h2 id="编写第一个rust程序"><a class="header" href="#编写第一个rust程序">编写第一个Rust程序</a></h2>
<p>在main.rs文件中输入Rust代码</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
  println!(&quot;Hello World!&quot;);
}
</code></pre></pre>
<h2 id="编译并运行程序"><a class="header" href="#编译并运行程序">编译并运行程序</a></h2>
<p>在main.rs文件上单击右键，选择 <strong>在终端中打开</strong>，然后执行以下命令</p>
<p><code>rustc main.rs</code></p>
<p>在刚刚的终端中输入</p>
<p><code>main.exe</code></p>
<p>终端上会输出</p>
<p><code>Hello World!</code></p>
<h2 id="分析这个程序"><a class="header" href="#分析这个程序">分析这个程序</a></h2>
<p>好了，我们已经创建了第一个Rust程序了，但这段代码到底是什么意思呢？现在让我们来分析一下：</p>
<ol>
<li>
<p><code>fn</code>表示定义一个 <strong>函数</strong>， <code>main</code>是这个函数的名字，花括号 <code>{}</code>里的语句则是这个函数的内容，Rust 要求所有函数体都要用花括号包裹起来。一般来说，将左花括号与函数声明置于同一行并以空格分隔，是良好的代码风格</p>
</li>
<li>
<p>名字为 <strong>main</strong>的函数在Rust里有特殊的作用，即程序的入口，程序就是从这里开始执行的</p>
</li>
<li>
<p><code>println!()</code>是一个宏，它的功能是打印圆括号<code>()</code>中的内容并换行，!是宏的标志，如果是调用函数，则没有!，关于宏我们会在以后的章节讲解</p>
</li>
<li>
<p>在Rust中，语句的末尾一般用分号<code>;</code>作为结束标志</p>
</li>
<li>
<p>Rust程序的编译与运行是彼此独立的，在运行 Rust 程序之前，必须先使用 Rust 编译器编译它，即输入 rustc 命令并传入源文件名称</p>
</li>
<li>
<p>Rust 是一种 <strong>预编译静态类型</strong>语言，这意味着你可以编译程序，并将可执行文件送给其他人，他们甚至不需要安装 Rust 就可以运行。这与解释性语言不同</p>
</li>
</ol>
<hr />
<p>仅仅使用 rustc 编译简单程序是没问题的，不过随着项目的增长，rustc就会难以满足需要，这种时候就需要包管理工具了，接下来介绍这个强大的工具—<strong>Cargo</strong></p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="hello-cargo"><a class="header" href="#hello-cargo">Hello Cargo</a></h1>
<p>要系统的学习Rust语言了，首先让我们来系统的认识一下Rust的包管理器—Cargo</p>
<h2 id="cargo简介"><a class="header" href="#cargo简介">cargo简介</a></h2>
<p>代码管理对于编程来说一直是一个重要的问题，各种不同的语言也都会采用不同的代码管理器，Rust作为一枚现代语言，综合了现有语言管理工具的优点，为我们提供了一个大杀器—— <strong>Cargo</strong></p>
<p>作为rust的代码组织管理工具，cargo提供了一系列的工具，从项目的建立、构建到测试、运行直至部署，为rust项目的管理提供尽可能完整的手段。同时，与rust语言及其编译器rustc本身的各种特性紧密结合。</p>
<h2 id="cargo入门"><a class="header" href="#cargo入门">cargo入门</a></h2>
<p>在我们安装Rust的时候就已经安装好了cargo</p>
<h3 id="创建项目"><a class="header" href="#创建项目">创建项目</a></h3>
<p>在我们存放代码的文件夹上单击右键，选择 <strong>在终端中打开</strong>，输入以下命令</p>
<p><code>cargo new hello_cargo --bin</code></p>
<p><code>--bin</code>是一个参数，代表这是一个<strong>bin</strong>包，Cargo默认创建bin包，所以该参数可以不加</p>
<h3 id="查看目录结构"><a class="header" href="#查看目录结构">查看目录结构</a></h3>
<p><strong>hellocargo</strong>文件夹下有一个<strong>src</strong> 和一个 <strong>Cargo.toml</strong> 文件，src文件夹下有一个 <strong>main.rs</strong>文件，它也在 hello_cargo 目录初始化了一个 git 仓库，以及一个 .gitignore 文件</p>
<pre><code> ├── Cargo.toml
 └── src
     └── main.rs
</code></pre>
<h3 id="编辑-src下的mainrs文件"><a class="header" href="#编辑-src下的mainrs文件">编辑 src下的main.rs文件</a></h3>
<p>cargo初始化的main.rs里会有一些默认内容，我们把它改为</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
     println!(&quot;Hello, Cargo!&quot;);
 } 
</code></pre></pre>
<h3 id="编译和运行"><a class="header" href="#编译和运行">编译和运行</a></h3>
<p>在hellocargo文件夹上单击右键，选择在在 <strong>终端中打开</strong>，输入以下命令</p>
<pre><code class="language-纯文本">cargo build
cargo build --release  这个是优化编译 
</code></pre>
<p>这两个命令分别会在以下文件夹下生成可执行文件</p>
<pre><code class="language-纯文本">cargo run             编译并运行
cargo run --release   同上
</code></pre>
<blockquote>
<p>./target/debug/hellocargo.exe</p>
</blockquote>
<blockquote>
<p>./target/release/hellocargo.exe</p>
</blockquote>
<h3 id="基于cargo的rust项目解构"><a class="header" href="#基于cargo的rust项目解构">基于Cargo的Rust项目解构</a></h3>
<p><code>cargo.toml</code>和<code>cargo.lock</code>文件总是位于项目根目录下</p>
<p>源代码位于<code>src</code>目录下</p>
<p>默认的库入口文件是<code>src/lib.rs</code></p>
<p>默认的可执行程序入口文件是<code>src/main.rs</code></p>
<p>其他可选的可执行文件位于<code>src/bin/*.rs</code>(这里每一个rs文件均对应一个可执行文件)</p>
<p>外部测试源代码文件位于<code>tests</code>目录下</p>
<p>示例程序源代码文件位于<code>examples</code></p>
<p>基准测试源代码文件位于<code>benches</code>目录下</p>
<h3 id="cargotoml与cargolock"><a class="header" href="#cargotoml与cargolock">Cargo.toml与Cargo.lock</a></h3>
<p><code>cargo.toml</code>和<code>cargo.lock</code>是cargo项目代码管理的核心两个文件，cargo工具的所有活动均基于这两个文件。</p>
<p><code>cargo.toml</code>是cargo特有的项目数据描述文件，存储了项目的所有信息</p>
<p><code>cargo.lock</code>不需要直接修改，是cargo工具根据同一项目的toml文件生成的项目依赖详细清单文件</p>
<p><em>Cargo.toml</em></p>
<pre><code class="language-纯文本">[package]
name = &quot;hello_cargo&quot;
version = &quot;0.1.&quot;
authors = [&quot;YourName &quot;]
[dependencies]
</code></pre>
<p><strong>TOML</strong>是Rust的官方配置文件格式，由像<code>[package]</code>或<code>[dependencies]</code>这样的段落组成，每一个段落又由多个字段组成，这些段落和字段就描述了项目组织的基本信息。</p>
<p><code>package</code> 下面的 <code>name</code> 字段表明项目的名称。 如果您发布 crate，那么 <code>crates.io</code> 将使用此字段标明的名称。 这也是编译时输出的二进制可执行文件的名称</p>
<p><code>version</code> 字段是使用<strong>语义版本控制</strong>的 crate 版本号</p>
<p><code>authors</code> 字段表明发布 crate 时的作者列表</p>
<p><code>dependencies</code> 这部分可以让你为项目添加依赖，依赖段落包括一下几种：</p>
<ul>
<li>
<p>基于rust官方仓库，通过版本说明来描述：</p>
</li>
<li>
<p>基于项目源代码的git仓库地址，通过URL来描述：</p>
</li>
<li>
<p>基于本地项目的绝对路径或者相对路径</p>
</li>
</ul>
<p>简单的示例：</p>
<pre><code class="language-纯文本">[dependencies]
typemap = &quot;0.3&quot;
plugin = &quot;0.2*&quot;
hammer = { version = &quot;0.5.0&quot;}
color = { git = &quot;https://github.com/bjz/color-rs&quot; }
geometry = { path = &quot;crates/geometry&quot; }
</code></pre>
<h3 id="定义集成测试用例"><a class="header" href="#定义集成测试用例">定义集成测试用例</a></h3>
<p>cargo另一个重要的功能，即将软件开发过程中必要且非常重要的测试环节进行集成，并通过代码属性声明或者toml文件描述来对测试进行管理。其中，单元测试主要通过在项目代码的测试代码部分前用#[test]属性来描述，而集成测试，则一般都会通过toml文件中的[[test]]段落进行描述。 例如，假设集成测试文件均位于tests文件夹下，则toml可以这样来写</p>
<pre><code class="language-纯文本">[[test]]
name = &quot;test1&quot;
path = &quot;tests/test1.rs&quot;

[[test]]
name = &quot;test2&quot;
path = &quot;tests/test2.rs&quot;
</code></pre>
<p>上述例子中，name字段定义了集成测试的名称，path字段定义了集成测试文件相对于本toml文件的路径。 看看，定义集成测试就是如此简单。 需要注意的是:</p>
<ol>
<li>
<p>如果没有在Cargo.toml里定义集成测试的入口，那么tests目录(不包括子目录)下的每个rs文件被当作集成测试入口</p>
</li>
<li>
<p>如果在Cargo.toml里定义了集成测试入口，那么定义的那些rs就是入口，不再默认指定任何集成测试入口.</p>
</li>
</ol>
<h3 id="定义示例和可执行文件"><a class="header" href="#定义示例和可执行文件">定义示例和可执行文件</a></h3>
<p>example用例的描述以及bin用例的描述也是cargo的常用功能</p>
<pre><code class="language-纯文本">[[example]]
name = &quot;examlpe1&quot;
path = &quot;examples/examlpe1.rs&quot;

[[bin]]
name = &quot;bin1&quot;
path = &quot;bin/bin1.rs&quot;
</code></pre>
<p>对于<code>[[example]]</code>和<code>[[bin]]</code>段落中声明的examples和bins，需要通过<code>cargo run --example NAME</code>或者<code>cargo run --bin NAME</code>来运行，其中NAME对应于你在name字段中定义的名称</p>
<h3 id="其他cargo命令"><a class="header" href="#其他cargo命令">其他Cargo命令</a></h3>
<p>cargo clean：清理target文件夹中的所有内容</p>
<p>cargo update：根据toml描述文件重新检索并更新各种依赖项的信息，并写入lock文件，例如依赖项版本的更新变化等等</p>
<p>cargo install：可用于实际的生产部署</p>
<p>cargo fmt：代码格式化工具</p>
<hr />
<p>从这章开始，请把Cargo当作习惯，对于简单项目， Cargo 并不比 rustc 提供了更多的优势，不过随着开发的深入，终将证明其价值</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="变量常量与原生类型"><a class="header" href="#变量常量与原生类型">变量、常量与原生类型</a></h1>
<h1 id="变量绑定"><a class="header" href="#变量绑定">变量绑定</a></h1>
<p>Rust 通过静态类型确保类型安全。变量绑定可以在声明时说明类型，不过在多数情况下， 编译器能够从上下文推导出变量的类型，从而大大减少了类型说明的工作。</p>
<p>使用 <code>let</code> 绑定操作可以将<strong>值</strong>绑定（bind）到<strong>变量</strong></p>
<pre><code class="language-Rust">fn main() {
  let a = 5;//类型推断
  let b: i32 = 10;//显式声明
  let c = 10i32;//另一种显式声明，value+type
  let d = c;//整数类型默认实现了Copy，所以下面变量c仍可使用
  
  //a = 10;   报错，变量默认不可更改
  
  // 编译器会对未使用的变量绑定产生警告；可以给变量名加上下划线前缀来消除警告。
  let _unused = 3u32;
}
</code></pre>
<h1 id="可变绑定"><a class="header" href="#可变绑定">可变绑定</a></h1>
<p>虽然变量默认不可变，但不可以把不可变变量理解为常量。在变量名前加上 <code>mut</code>关键字，即可让变量变为可变变量</p>
<pre><code class="language-Rust">fn main() {
  let mut a :f64 = 2.0;
  pritnln!(&quot;{}&quot;,a);
  //改变a的绑定
  a = 5.0;
  println!(&quot;{}&quot;,a);
  //重新将a绑定为不可变
  let a = a;//这是Rust的遮蔽特性，允许声明同名变量来遮蔽先前的变量
}
</code></pre>
<h1 id="常量"><a class="header" href="#常量">常量</a></h1>
<p>Rust 有两种常量，可以在任意作用域声明，包括全局作用域。它们都需要显式的类型声明：</p>
<ul>
<li>
<p><code>const</code>：不可改变的值（通常使用这种）。</p>
</li>
<li>
<p><code>static</code>：具有 <code>'static</code> 生命周期的， <code>static mut</code> 关键字可生命可变常量，但不等同于变量</p>
</li>
</ul>
<p>有个特例就是 <code>&quot;string&quot;</code> 字面量。它可以不经改动就被赋给一个 <code>static</code> 变量，因为它 的类型标记：<code>&amp;'static str</code> 就包含了所要求的生命周期 <code>'static</code>。其他的引用类型都 必须特地声明，使之拥有<code>'static</code> 生命周期。这两种引用类型的差异似乎也无关紧要，因 为无论如何，<code>static</code> 变量都得显式地声明。（将会在<a href="https://www.wolai.com/aVx4WUi4SBNJJFFWDiueUB">10.可变性、所有权、租借和生命周期</a>中详细讲解）</p>
<pre><code class="language-Rust">// 全局变量是在在所有其他作用域之外声明的。
static LANGUAGE: &amp;'static str = &quot;Rust&quot;;
const  THRESHOLD: i32 = 10;

fn is_big(n: i32) -&gt; bool {
    // 在一般函数中访问常量
    n &gt; THRESHOLD
}

fn main() {
    let n = 16;

    // 在 main 函数（主函数）中访问常量
    println!(&quot;This is {}&quot;, LANGUAGE);
    println!(&quot;The threshold is {}&quot;, THRESHOLD);
    println!(&quot;{} is {}&quot;, n, if is_big(n) { &quot;big&quot; } else { &quot;small&quot; });

    // 报错！不能修改一个 `const` 常量。
    THRESHOLD = 5;
    //^ 注释掉此行
}
</code></pre>
<h1 id="let解构"><a class="header" href="#let解构">let解构</a></h1>
<p>let不只是用于声明变量、绑定变量，实际上let是一种匹配模式，拥有十分强大的功能</p>
<p><strong>例如：</strong></p>
<pre><code class="language-Rust">fn main() {
  let (a, mut b): (bool, bool) = (true, false);
  println!(&quot;a = {:?}, b = {:?}&quot;, a, b);
}
</code></pre>
<h1 id="原生类型"><a class="header" href="#原生类型">原生类型</a></h1>
<p>在上面的例子中，我们见到了 <code>i32</code> <code>f64</code> <code>bool</code>等数据类型，它们是Rust的原生类型，Rust的原生类型有以下几类：</p>
<ul>
<li>
<p>布尔类型：只有两个值， <code>true</code> 和 <code>false</code></p>
</li>
<li>
<p>字符类型：表示单个Unicode字符，储存为 <code>u8</code> </p>
</li>
<li>
<p>数值类型：有符号整型( <code>i8</code> <code>i16</code> <code>i32</code> <code>i64</code> <code>i128</code> <code>isize</code>)、无符号整型( <code>u8</code> <code>u16</code> <code>u32</code> <code>u64</code> <code>u128</code> <code>usize</code>)和浮点型( <code>f32</code> <code>f64</code>)</p>
</li>
<li>
<p>字符串类型：其底层为不定长类型 <code>str</code>，更常用的是字符串切片 <code>&amp;str</code>和堆分配字符串 <code>String</code>，字符串切片是静态的，有固定大小且不可改变，堆分配字符串是可变的</p>
</li>
<li>
<p>数组：有固定大小，且元素为同一类型，可表示为 <code>[T; N]</code></p>
</li>
<li>
<p>切片：引用数组的一部分数据且无需复制，可表示为 <code>&amp;[T]</code></p>
</li>
<li>
<p>元组：有固定大小，元素类型可不同的有序列表</p>
</li>
<li>
<p>指针：最底层是裸指针 <code>*const T</code>和 <code>*mut T</code>，解引用它们是不安全的需要放到 <code>unsafe</code>块里，详见<a href="https://www.wolai.com/fc6U4hYttUoYiGDiR7CSnW">21.Unsafe</a></p>
</li>
<li>
<p>函数：本质是一个函数指针</p>
</li>
<li>
<p>元类型：其唯一的值是 <code>()</code></p>
</li>
</ul>
<pre><code class="language-Rust">//如果没有必要，以后的示例将不会有 fn main() {} 等
//下面按顺序展示一下这些类型
let t = true;
let f: bool = false;

let c = 'c';

let x = 100;
let y: u32 = 123_456;
let z: f64 = 1.2e+3;// 浮点数可用科学计数法
let zero = z.abs_sub(123.4);
let bin = 0b111_000;
let oct = 0o1234_5670;
let hex = 0xf23a9;

let str = &quot;hello world&quot;;
let mut string = str.to_string();

let a = [0, 1, 2, 3];
let b = &amp;a[1..3];
let mut ten_zeros: [i64;10] = [0; 10];

let tuple: (i32,&amp;str) = (50, &quot;hello&quot;);
let (fifty, _) = tuple;
let hello = tuple.1;

let x = 5;
let p = &amp;x as *const i32;
let point_at = unsafe{*p}; 

fn func(x:i32) -&gt; i32 {
  x
} 
let function: fn(i32) -&gt; i32 = func; 
</code></pre>
<p>有几点是需要特别注意的：</p>
<ul>
<li>
<p>数值类型可以使用<code>_</code>来增加可读性。</p>
</li>
<li>
<p>Rust支持单字节字符<code>b'H'</code>和单字节字符串<code>b&quot;Hello&quot;</code>，仅限于ASCII字符。 使用<code>r#&quot;...&quot;#</code>标记来表示原始字符串，不需要对特殊字符进行转义。</p>
</li>
<li>
<p>使用<code>&amp;</code>符号将<code>String</code>类型转换成<code>&amp;str</code>类型很容易， 但是使用<code>to_string()</code>方法将<code>&amp;str</code>转换到<code>String</code>类型涉及到分配内存， 除非很有必要否则不要这么做。</p>
</li>
<li>
<p>数组的长度是不可变的，动态的数组称为Vec，可以使用宏<code>vec!</code>创建。</p>
</li>
<li>
<p>元组可以使用<code>==</code>和<code>!=</code>运算符来判断是否相同。</p>
</li>
<li>
<p>不多于32个元素的数组和不多于12个元素的元组在值传递时是自动复制的。</p>
</li>
<li>
<p>Rust不提供原生类型之间的隐式转换，只能使用<code>as</code>关键字显式转换。</p>
</li>
<li>
<p>可以使用<code>type</code>关键字定义某个类型的别名，并且应该采用驼峰命名法，这在解决非常长的变量名时非常有用，最常见的时<code>impl</code>块中的<code>Self</code>别名。</p>
</li>
</ul>
<pre><code class="language-Rust">let decimal = 65.4321_f32;
let integer = decimal as u8;
let character = integer as char;

type Color = (u8, u8, u8);
type Point = (u8, u8);
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="数组动态数组与字符串"><a class="header" href="#数组动态数组与字符串">数组、动态数组与字符串</a></h1>
<p>在上一节中，我们了解到了Rust的原生类型，其中有一些类型比较复杂，下面让我们具体的学习一下这些类型</p>
<h2 id="数组和动态数组"><a class="header" href="#数组和动态数组">数组和动态数组</a></h2>
<h3 id="数组与切片"><a class="header" href="#数组与切片">数组与切片</a></h3>
<p>数组用于储存相同类型的数据集，[T; N] 表示一个T类型，N个元素的数组，数组的大小必须固定，需要在编译的时候确定下来</p>
<pre><code class="language-Rust">let mut array :[i32; 3]= [0; 3];
array[1] = 1;
array[2] = 2;
for x in &amp;array {
  println!(&quot;{}&quot;,x);
} 
</code></pre>
<p><code>array[1] = 2</code>的意思是将索引为 <em>1</em>的元素的值改为 <em>2</em>，需要注意的是，Rust中，数组第一个元素的索引为 <strong>0</strong>。 <code>for x in &amp;array {...}</code>是一个循环，这个循环将会打印 <em>0 1 2</em>，关于循环的内容将会在<a href="https://www.wolai.com/ok8S8UqwJvM5KGhy2cuLY6">2.5.控制流</a>提到</p>
<p>切片（slice）类型和数组类似，但其大小在编译时是不确定的。切片是一个<strong>双字对象</strong>，第一个字是一个指向数据的<strong>指针</strong>，第二个字是切片的<strong>长度</strong>。这 个“字”的宽度和 usize 相同，slice 可以用来借用数组的一部分。slice 的类型标记为 <code>&amp;[T]</code></p>
<pre><code class="language-Rust">use std::mem;

// 此函数借用一个 slice
fn analyze_slice(slice: &amp;[i32]) {
    println!(&quot;该切片的第一个元素是: {}&quot;, slice[0]);
    println!(&quot;这个切片有 {} 个元素&quot;, slice.len());
}

fn main() {
    // 定长数组（类型标记是多余的）
    let xs: [i32; 5] = [1, 2, 3, 4, 5];

    // 所有元素可以初始化成相同的值
    let ys: [i32; 500] = [0; 500];

    // 下标从 0 开始
    println!(&quot;first element of the array: {}&quot;, xs[0]);
    println!(&quot;second element of the array: {}&quot;, xs[1]);

    // `len` 返回数组的大小
    println!(&quot;array size: {}&quot;, xs.len());

    // 数组是在栈中分配的
    println!(&quot;array occupies {} bytes&quot;, mem::size_of_val(&amp;xs));

    // 数组可以自动被借用成为 slice
    println!(&quot;borrow the whole array as a slice&quot;);
    analyze_slice(&amp;xs);

    // slice 可以指向数组的一部分
    println!(&quot;borrow a section of the array as a slice&quot;);
    analyze_slice(&amp;ys[1 .. 4]);

    // 越界的下标会引发致命错误（panic）
    println!(&quot;{}&quot;, xs[5]);
}

</code></pre>
<h2 id="动态数组vec"><a class="header" href="#动态数组vec">动态数组Vec</a></h2>
<p>动态数组是一种基于堆内存申请的连续动态数据类型，拥有 O(1) 时间复杂度的索引、压入（push）、弹出（pop)</p>
<pre><code class="language-Rust">//创建空Vec
let v: Vec&lt;i32&gt; = Vec::new();
//使用宏创建空Vec
let v: Vec&lt;i32&gt; = vec![];
//创建包含5个元素的Vec
let v = vec![1, 2, 3, 4, 5];
//创建十个零的Vec
let v = vec![0; 10];
//创建可变的Vec，并压入元素3
let mut v = vec![1, 2];
v.push(3);
//创建拥有两个元素的Vec，并弹出一个元素
let mut v = vec![1, 2];
let two = v.pop();
//创建包含三个元素的可变Vec，并索引一个值和修改一个值
let mut v = vec![1, 2, 3];
let three = v[2];
v[1] = v[1] + 5;
</code></pre>
<h1 id="字符串"><a class="header" href="#字符串">字符串</a></h1>
<p>Rust里有两种字符串类型， <code>String</code>和 <code>str</code></p>
<h2 id="str"><a class="header" href="#str">&amp;str</a></h2>
<p><code>str</code>类型很少使用， <code>&amp;str</code>类型使用的较多，本质是 <code>[u8]</code>类型的切片 <code>&amp;[u8]</code>，是一种大小固定的类型，常见的的字符串字面值就是 <code>&amp;'static str</code>类型，这是一种带有 <code>'static</code>生命周期的 <code>&amp;str</code>类型，在这里您不必深入了解</p>
<pre><code class="language-Rust">let hello = &quot;Hello, world!&quot;;
let hello: &amp;'static str = &quot;Hello, world!&quot;;
</code></pre>
<h2 id="string"><a class="header" href="#string">String</a></h2>
<p><code>String</code>是一个带有的 <code>vec:Vec&lt;u8&gt;</code>成员的结构体，您可以理解为 <code>str</code>类型的动态形式。 它们的关系相当于 <code>[T]</code>和 <code>Vec&lt;T&gt;</code>的关系。所以 String 类型也有压入和弹出</p>
<pre><code class="language-Rust">// 创建一个空的字符串
let mut s = String::new();
// 从 `&amp;str` 类型转化成 `String` 类型
let mut hello = String::from(&quot;Hello, &quot;);
// 压入字符和压入字符串切片
hello.push('w');
hello.push_str(&quot;orld!&quot;);

// 弹出字符。
let mut s = String::from(&quot;foo&quot;);
assert_eq!(s.pop(), Some('o'));
assert_eq!(s.pop(), Some('o'));
assert_eq!(s.pop(), Some('f'));
assert_eq!(s.pop(), None);
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="24结构体与枚举"><a class="header" href="#24结构体与枚举">2.4.结构体与枚举</a></h1>
<h1 id="结构体"><a class="header" href="#结构体">结构体</a></h1>
<p><strong>结构体</strong> 是一种记录类型，所包含的每个 <strong>域</strong> 都有一个名称。 每个结构体也都有一个名称，通常以 <strong>大写字母</strong> 开头，使用 <strong>驼峰命名法</strong>。元组结构体是由 <strong>元组</strong> 和 <strong>结构体</strong> 混合构成，元组结构体有名称，但是它的域没有。当元组结构体只有一个域时，称为新类型。没有域的结构体，称为类单元结构体 。结构体中的值默认是不可变的，需要给结构体加上mut使其可变</p>
<pre><code class="language-Rust">struct Student {
        name: String,
        grade: i8,
        class: i8,
        id: i8,
}
let mut bob = Student {
        name: String::from(&quot;Bob&quot;),
        class: 1,
        grade: 2,
        id: 123,
};
bob.grade = 1;

struct Color(u8, u8, u8);
let android_green = Color(0xa4, 0xc6, 0x39);
let Color(red, green, blue) = android_green;

struct Digit(i32);
let v = vec![0, 1, 2];
let d: Vec&lt;Digit&gt; = v.into_iter().map(Digit).collect();

struct Inches(i32);
let length = Inches(10);
let Inches(integer_length) = length;

struct EmptyStruct;
let empty = EmptyStruct;
</code></pre>
<p>关于结构体的更多知识，我们将在后面的章节继续讲</p>
<h1 id="枚举"><a class="header" href="#枚举">枚举</a></h1>
<p><strong>枚举</strong> 是一种代表一系列子数据类型的集合，可用于分类，通过 <code>::</code>来获得每个元素的名称</p>
<pre><code class="language-Rust">enum Book {
        Pbook(u32),
        Ebook { url: String }, //枚举无法访问结构体内字段
    }
    let book = Book::Pbook(1010);
    let _ebook = Book::Ebook {
        url: String::from(&quot;https://xx.xx&quot;),
    };
match book {
        //match可作为返回表达式，但需要保证每个语句返回值相同
        Book::Pbook(i) =&gt; {
            //元组属性此处需设置临时变量
            println!(&quot;Pbook {}&quot;, i);
        }
        Book::Ebook { url } =&gt; {
            //结构体属性此处应与结构体字段相同
            println!(&quot;Ebook {}&quot;, url);
        }
    }

</code></pre>
<p>多通过 <code>match</code>对枚举进行预处理，关于match的知识，我们将在<a href="https://www.wolai.com/ok8S8UqwJvM5KGhy2cuLY6">2.5.控制流</a>中讲到</p>
<p>与结构体一样，枚举中的元素默认不能使用关系运算符进行比较 (如<code>==</code>, <code>!=</code>, <code>&gt;=</code>)， 也不支持像<code>+</code>和<code>*</code>这样的双目运算符，需要自己实现，或者使用<code>match</code>进行匹配。</p>
<p>枚举默认也是私有的，如果使用<code>pub</code>使其变为公有，则它的元素也都是默认公有的，这一点与结构体不同。 <strong>注意</strong>：即使结构体是公有的，它的域仍然是默认私有的。这里的共有/私有仍然 是针对其定义所在的模块之外</p>
<h1 id="use引入作用域"><a class="header" href="#use引入作用域">Use引入作用域</a></h1>
<p>使用 <code>use</code> 声明的话，就可以不写出名称的完整路径了，关于<code>use</code>的更多内容见<a href="https://www.wolai.com/p5UoZr3hGq2beycMbHTNXo">14.1.mod与crate</a></p>
<pre><code class="language-Rust">// 该属性用于隐藏对未使用代码的警告。
#![allow(dead_code)]

enum People {
    Rich,
    Poor,
}

enum Work {
    Farmer,
    Soldier,
}

fn main() {
    // 显式地 `use` 各个名称使他们直接可用，而不需要指定它们来自 `People`。
    use People::{Poor, Rich};
    // 自动地 `use` `Work` 内部的各个名称。
    use Work::*;

    // `Poor` 等价于 `People::Poor`。
    let people = Poor;
    // `Farmer` 等价于 `Work::Farmer`。
    let work = Farmer;

    match people {
        // 注意这里没有用完整路径，因为上面显式地使用了 `use`。
        Rich =&gt; println!(&quot;万恶的有钱人（笑）&quot;),
        Poor =&gt; println!(&quot;可怜的穷人&quot;),
    }

    match work {
        // 再次注意到没有用完整路径。
        Farmer =&gt; println!(&quot;种地啦&quot;),
        Soldier  =&gt; println!(&quot;打仗啦&quot;),
    }
}

</code></pre>
<h1 id="c语言风格的枚举"><a class="header" href="#c语言风格的枚举">C语言风格的枚举</a></h1>
<p>Rust的枚举也可以像C语言那样</p>
<pre><code class="language-Rust">// 拥有隐式辨别值（implicit discriminator，从 0 开始）的 enum
enum Number {
    Zero,
    One,
    Two,
}

// 拥有显式辨别值（explicit discriminator）的 enum
enum Color {
    Red = 0xff0000,
    Green = 0x00ff00,
    Blue = 0x0000ff,
}

fn main() {
    // `enum` 可以转成整型。
    println!(&quot;zero 是 {}&quot;, Number::Zero as i32);//as 用来类型转换
    println!(&quot;one 是 {}&quot;, Number::One as i32);

    println!(&quot;玫瑰是 #{:06x} 色的&quot;, Color::Red as i32);
    println!(&quot;天空是 #{:06x} 色的&quot;, Color::Blue as i32);
}
</code></pre>
<p><a href="2_quickly_start/./list.html">链表</a></p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="25控制流"><a class="header" href="#25控制流">2.5.控制流</a></h1>
<h1 id="if"><a class="header" href="#if">if</a></h1>
<p><code>If</code>是分支的一种，可以与<code>else</code>和<code>else if</code>连用。条件不需要小括号括，但条件后面必须跟一个代码块。Rust中的if是一个表达式，可以赋给一个变量</p>
<pre><code class="language-Rust">let x = 5;
let y = if x==5{true}else{false} 
</code></pre>
<p>Rust是基于表达式和语句的语言</p>
<ul>
<li>
<p>如<code>let</code>等语句，它就是语句，以分号结尾，无返回值</p>
</li>
<li>
<p>如<code>if</code> <code>match</code>等语句，甚至是<code>5</code> <code>'a'</code>等字面值，它们就是表达式，拥有返回值，表达式后加上分号表示丢弃返回值，将会返回<code>()</code></p>
</li>
</ul>
<p>所以以下代码会报错</p>
<pre><code class="language-Rust">let a = (let b = 5);
let c = if true {10;}else{5;}; 
</code></pre>
<p>赋值语句如<code>x=1</code>也是表达式，返回值为<code>()</code></p>
<h1 id="for"><a class="header" href="#for">for</a></h1>
<p><code>for</code>的抽象结构如下</p>
<pre><code class="language-Rust">for 值 in 迭代器{
  code
}
</code></pre>
<p>关于迭代器，先举几个简单的例子</p>
<p><code>1..10</code> <code>1..=10</code> <code>[1,2,3].iter()</code></p>
<h1 id="while"><a class="header" href="#while">While</a></h1>
<pre><code class="language-Rust">while 布尔表达式{
  code
}
</code></pre>
<h1 id="loop"><a class="header" href="#loop">Loop</a></h1>
<p><code>loop</code>是rust中专门的无限循环</p>
<pre><code class="language-Rust">loop{
  code
}
</code></pre>
<h1 id="跳出循环与标签"><a class="header" href="#跳出循环与标签">跳出循环与标签</a></h1>
<p>对于循环，可以使用<code>break</code>强制退出循环，也可以使用<code>continue</code>结束本次循环并进入下一次循环，这两个关键字后面也可以跟一个返回值。</p>
<p>也可以使用标签退出指定循环</p>
<pre><code class="language-Rust">'outer: loop{
  'inner: loop{
    println!(&quot;退出外部循环&quot;)；
    break 'outer
  }
}
</code></pre>
<h1 id="match"><a class="header" href="#match">Match</a></h1>
<p>match是一个强大的匹配模式，我们将在<a href="https://www.wolai.com/w8BKEkDopqAqWLiKaWKqYs">7.1.match关键字</a>中详细讲解，接下来我们看几个例子</p>
<pre><code class="language-Rust">let day = 5;

match day {
  0|6=&gt;println!(&quot;休息日&quot;)，
  1...5=&gt;println!(&quot;工作日&quot;)，
  _=&gt;println!(&quot;none&quot;),
} 
</code></pre>
<p><code>|</code>用于匹配多个值，<code>...</code>用于匹配一个范围，包括开头结尾，因为<code>match</code>进行的是穷举性匹配，所以需要一个<code>_</code>匹配剩下的所有值</p>
<p>可以使用<code>@</code>来绑定一个变量</p>
<pre><code class="language-Rust">let a = 1;
match a{
  b @ 1...3=&gt;println!(&quot;a={}&quot;,b),
  _=&gt;println!(&quot;a不在区间[1,3]中&quot;),
}  
</code></pre>
<p>可以使用<code>ref</code>获得一个引用</p>
<pre><code class="language-Rust">let a = 1;
let mut b = 2;
match a{
  ref x=&gt;println!(x),
} 
match b{
  ref mut x=&gt;println!(x),
} 
</code></pre>
<p>match可用于解构复合类型，如元组</p>
<pre><code class="language-Rust">let point = (0,2);
match point{
  (0,y)=&gt;println!(&quot;这个点在y轴上，纵坐标为 {}&quot;，y),
  (x,0)=&gt;println!(&quot;这个点在x轴上，横坐标为 {}&quot;，x),
  (0,0)=&gt;println!(&quot;这个点是原点&quot;),
  _=&gt;println!(&quot;这个点不在坐标轴上&quot;),
}  
</code></pre>
<p>解构 结构体，可以使用<code>..</code>来忽略变量</p>
<pre><code class="language-Rust">struct Point{
  x:i32,
  y:i32,
}
let point = Point{x:10,y:10}
 match point{
   Point{x,..}=&gt;println!(&quot;x is {}&quot;,x),
}
 enum Int{
   Value(i32),
   N
} 
let value = Int::Value(10);

match value{
  Int::Value(i) if i&gt;5=&gt;println!(&quot;这个数字大于5&quot;),
  Int::Value(..)=&gt;println!(&quot;是一个数字&quot;),
  Int::N=&gt;println!(&quot;不是数字&quot;),
} 
</code></pre>
<h1 id="if-let-与while-let"><a class="header" href="#if-let-与while-let">if let 与while let</a></h1>
<p>if let 与 while let 相当于精简版的match，用于解决一些匹配项很少或者只关心其中几个值时的匹配,<code>Some</code>与<code>None</code>是<code>Option</code>枚举唯二的两个变体，用于表示一个值是否存在，<code>Option</code>会在<a href="https://www.wolai.com/gbgLL5qtfLSB4nv8TaAR5k">15.错误处理</a>中详细讲解</p>
<pre><code class="language-Rust">let a = Some(1);
let mut b = Some(0); 

if let Some(i) = a{
  println!(&quot;匹配到了数字 {}&quot;,i);
}
while let Some(i) = b{
  if i&gt;3{
    println!(&quot;匹配数字超过3了&quot;);
    b = None
  }else{
    println!(&quot;这个数字是{:?},给它加一&quot;,i);
    b = Some(i+1);
  }
} 
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="26函数与方法"><a class="header" href="#26函数与方法">2.6.函数与方法</a></h1>
<h1 id="函数"><a class="header" href="#函数">函数</a></h1>
<p>声明函数与<code>fn</code>关键字</p>
<pre><code class="language-Rust">fn function(x:i32)-&gt;i32{
  x
}
</code></pre>
<p>其中函数参数的类型不能省略，可以有多个参数，但是最多只能返回一个值， 提前返回使用<code>return</code>关键字否则默认将最后一行的表达式返回，关于表达式和语句我们在<a href="https://www.wolai.com/f5r4ZNSJGu1JwUGfsj9F3z">Rust是基于表达式和语句的语言</a>中讲到过。</p>
<p>Rust编译器会对未使用的函数提出警告， 可以使用属性<code>#[allow(dead_code)]</code>禁用无效代码检查</p>
<p>Rust有一个特殊特性适用于发散函数 (diverging function)，它不返回</p>
<pre><code class="language-Rust">fn diverges() -&gt; ! {
    panic!(&quot;这个函数永不返回&quot;);
}
</code></pre>
<p><code>panic!</code>是一个宏，会使当前执行线程 <em>panic</em>并打印给定信息。返回类型<code>!</code>可用作任何类型</p>
<pre><code class="language-Rust">let x: i32 = diverges();
let y: String = diverges();
</code></pre>
<h1 id="匿名函数"><a class="header" href="#匿名函数">匿名函数</a></h1>
<p>Rust使用闭包 (closure) 创建匿名函数</p>
<pre><code class="language-Rust">let out = 12;//闭包可使用外部变量
let num1 = |i,j|i+j+out;//闭包可根据上下文自动推导类型
let num2 = |i:i32,j:i32|i*j+out;//也可以指定类型
let a = 1;
let b = 2;
let c = num1(a,b);
let d = num2(a,b);
println!(&quot;{},{}&quot;,c,d);
</code></pre>
<p>其中<code>||</code>之间是闭包的参数，其后是函数的主体，闭包<code>num1</code>借用了它作用域中的<code>let</code>绑定<code>out</code>。如果要让闭包获得所有权， 可以使用<code>move</code>关键字</p>
<pre><code class="language-Rust">let mut num = 5;

{
    let mut add = move |x: i32| num += x;   // 闭包通过move获取了num的所有权
    add(5);
}
// 下面的num在被move之后还能继续使用是因为其实现了Copy特性
assert_eq!(5, num);
</code></pre>
<h1 id="高阶函数"><a class="header" href="#高阶函数">高阶函数</a></h1>
<p>Rust支持高阶函数，允许闭包作为参数，高阶函数会在<a href="https://www.wolai.com/35pfc2mANWfB6wZMJDCLCf">6.4.高阶函数</a>中继续讲解</p>
<pre><code class="language-Rust">fn add_one(x: i32) -&gt; i32 { x + 1 }

fn apply&lt;F&gt;(f: F, y: i32) -&gt; i32//接受一个类型F与i32，返回i32
    where F: Fn(i32) -&gt; i32//对类型F的约束，下一节会有提到
{
    f(y) * y//函数体
}

fn factory(x: i32) -&gt; Box&lt;Fn(i32) -&gt; i32&gt; {//返回一个函数
    Box::new(move |y| x + y)
}

fn main() {
    let transform: fn(i32) -&gt; i32 = add_one;//函数指针
    let f0 = add_one(2i32) * 2;
    let f1 = apply(add_one, 2);
    let f2 = apply(transform, 2);
    println!(&quot;{}, {}, {}&quot;, f0, f1, f2);//这三个是相等的

    let closure = |x: i32| x + 1;
    let c0 = closure(2i32) * 2;
    let c1 = apply(closure, 2);
    let c2 = apply(|x| x + 1, 2);
    println!(&quot;{}, {}, {}&quot;, c0, c1, c2);

    let box_fn = factory(1i32);
    let b0 = box_fn(2i32) * 2;
    let b1 = (*box_fn)(2i32) * 2;
    let b2 = (&amp;box_fn)(2i32) * 2;
    println!(&quot;{}, {}, {}&quot;, b0, b1, b2);

    let add_num = &amp;(*box_fn);
    let translate: &amp;Fn(i32) -&gt; i32 = add_num;
    let z0 = add_num(2i32) * 2;
    let z1 = apply(add_num, 2);
    let z2 = apply(translate, 2);
    println!(&quot;{}, {}, {}&quot;, z0, z1, z2);
}
</code></pre>
<h1 id="方法"><a class="header" href="#方法">方法</a></h1>
<p>Rust通过<code>impl</code>关键字在<code>struct</code>、<code>enum</code>或者<code>trait</code>对象的上下文实现方法调用语法，一个对象可以有多个 <code>impl</code>块 。 关联函数的第一个参数通常为<code>self</code>参数，有3种变体：</p>
<ul>
<li>
<p><code>self</code>，允许实现者移动和修改对象，对应的闭包特性为<code>FnOnce</code>。</p>
</li>
<li>
<p><code>&amp;self</code>，既不允许实现者移动对象也不允许修改，对应的闭包特性为<code>Fn</code>。</p>
</li>
<li>
<p><code>&amp;mut self</code>，允许实现者修改对象但不允许移动，对应的闭包特性为<code>FnMut</code></p>
</li>
</ul>
<pre><code class="language-Rust">/// 矩形结构体
struct Rectangular{
    width:u32,
    height:u32,
}
impl Rectangular{//为该结构体创建方法
    /// 创建矩形
    /// # Example
    fn new(width:u32, height:u32)-&gt;Rectangular{//不含self参数的方法也称为静态方法
        Rectangular{width,height,}
    }
    /// 快速创建正方形
    /// # Example
    fn square(size:u32)-&gt;Rectangular{
        Rectangular{width:size,height:size}
    }
    /// 获得矩形宽
    /// # Example
    fn get_width(&amp;self) -&gt; u32 {
        self.width
    }
    /// 获得矩形长
    /// # Example
    fn get_height(&amp;self) -&gt; u32 {
        self.height
    }
    /// 求矩形面积
    /// # Example
    fn area(&amp;self) -&gt; u32{
        self.width*self.height
    }
    /// 求矩形对角线
    /// # Example
    fn diagonal(&amp;self)-&gt;f64{
        let x = self.width as f64;
        let y = self.height as f64;
        let z = x*x+y*y;
        z.sqrt()
    }
}
fn main() {
    let a = Rectangular::new(10, 20);
    let b = a.area();
    println!(&quot;这个矩形的面积是：{}&quot;,b);

    let c= Rectangular::square(20);
    let d = c.area();
    println!(&quot;这个正方形的面积是：{}&quot;,d);

    let e = Rectangular::new(3, 4);
    let f = e.diagonal();
    println!(&quot;这个矩形的对角线是：{}&quot;,f);

    let g = Rectangular::new(10,40);
    println!(&quot;这个矩形的长是：{}，宽是：{}&quot;,g.get_width(),g.get_height());
}
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="27特性泛型与多态"><a class="header" href="#27特性泛型与多态">2.7.特性、泛型与多态</a></h1>
<h1 id="特性与接口"><a class="header" href="#特性与接口">特性与接口</a></h1>
<p>为了描述类型可以实现的抽象接口，Rust引入了特性 <code>trait</code> 来定义<strong>函数类型签名</strong>，特性就相当于其他语言中的接口</p>
<pre><code class="language-Rust">//通过trait关键字定义特性
trait HasArea {//这个特性使area函数必须接受一个&amp;eslf类型，返回一个f64类型
    fn area(&amp;self) -&gt; f64;
}

struct Circle {
    x: f64,
    y: f64,
    radius: f64,
}

impl HasArea for Circle {//将特性应用于该结构体
    fn area(&amp;self) -&gt; f64 {//实现特性
        std::f64::consts::PI * (self.radius * self.radius)
    }
}

struct Square {
    x: f64,
    y: f64,
    side: f64,
}

impl HasArea for Square {
    fn area(&amp;self) -&gt; f64 {
        self.side * self.side
    }
}

fn print_area&lt;T: HasArea&gt;(shape: T) {
    println!(&quot;This shape has an area of {}&quot;, shape.area());
}
</code></pre>
<p>其中函数<code>print_area()</code>中的<strong>泛型参数</strong><code>T</code>（<a href="https://www.wolai.com/k8F6paRKSbf3mPoeWd7TZF">泛型与多态</a>）被添加了一个名为<code>HasArea</code>的<strong>特性约束</strong>， 用以确保任何实现了<code>HasArea</code>的类型将拥有一个.area()方法。 如果需要多个<strong>特性限定</strong>，可以使用<code>+</code>操作符</p>
<pre><code class="language-Rust">use std::fmt::Debug;

fn foo&lt;T: Clone, K: Clone + Debug&gt;(x: T, y: K) {
    x.clone();
    y.clone();
    println!(&quot;{:?}&quot;, y);
}

fn bar&lt;T, K&gt;(x: T, y: K)
    where T: Clone,
          K: Clone + Debug
{
    x.clone();
    y.clone();
    println!(&quot;{:?}&quot;, y);
}
</code></pre>
<p>其中第二个例子使用了更灵活的<code>where</code>从句，它还允许限定的左侧可以是任意类型， 而不仅仅是类型参数</p>
<p>定义在特性中的方法称为<strong>默认方法</strong>，可以被该特性的实现<strong>覆盖</strong>。 此外，特性之间也可以存在<strong>继承</strong></p>
<pre><code class="language-Rust">trait Foo {
    fn foo(&amp;self);

    // 默认方法
    fn bar(&amp;self) { println!(&quot;BAR！&quot;); }
}

// 继承
trait FooBar : Foo {
    fn foobar(&amp;self);
}

struct Baz;

impl Foo for Baz {
    fn foo(&amp;self) { println!(&quot;foo&quot;); }
}

impl FooBar for Baz {
    fn foobar(&amp;self) { println!(&quot;foobar&quot;); }
}
</code></pre>
<p>如果两个不同特性的方法具有相同的名称，可以使用<strong>通用函数调用语法</strong></p>
<pre><code class="language-Rust">// 短形式
Trait::method(args);

// 展开形式
&lt;Type as Trait&gt;::method(args);
</code></pre>
<p>关于实现特性的几条限制：</p>
<ul>
<li>
<p>如果一个特性不在当前作用域内，它就不能被实现。</p>
</li>
<li>
<p>不管是特性还是<code>impl</code>，都只能在当前的<strong>crate</strong>内起作用。</p>
</li>
<li>
<p>带有特性约束的泛型函数使用<strong>单态化实现</strong>， 所以它是<strong>静态派分</strong>的</p>
</li>
</ul>
<h1 id="泛型与多态"><a class="header" href="#泛型与多态">泛型与多态</a></h1>
<p><strong>泛型</strong>在类型理论中称作<strong>参数多态</strong>，即对于给定参数可以有多种形式的函数或类型</p>
<p><code>Option</code>枚举是rust类型系统中的一部分，用于表示不存在的值，其定义如下<code>&lt;T&gt;</code>就是一个泛型，Rust程序员习惯使用<code>&lt;T&gt;</code>作为泛型</p>
<pre><code class="language-Rust">enum Option&lt;T&gt; {
    Some(T),
    None,
}
</code></pre>
<p>Option的典型用法</p>
<pre><code class="language-Rust">let a: Option&lt;i32&gt; = Some(1);
let b: Option&lt;f64&gt; = Some(1.0f64);
</code></pre>
<p>泛型参数也可以用于函数参数和结构体</p>
<pre><code class="language-Rust">fn point&lt;T, U&gt;(a: T, b: U) -&gt; (T, U) {
    (a, b)
}
let couple = point(1, 2.0);

struct Point&lt;T&gt; {
    x: T,
    y: T,
}
let int_origin = Point { x: 0, y: 0 };
let float_origin = Point { x: 0.0, y: 0.0 };
</code></pre>
<p>对于多态函数，有两种<strong>派分</strong>机制：<strong>静态派分</strong>和<strong>动态派分</strong>。 前者类似于C++的模板，Rust会生成适用于指定类型的特殊函数，然后在被调用的位置进行替换， 好处是允许函数被内联调用，运行比较快，但是会导致<strong>代码膨胀</strong>； 后者类似于Go的interface，Rust通过引入<strong>特性对象</strong>来实现， 在运行期查找<strong>虚表</strong>来选择执行的方法。特性对象&amp;Foo具有和特性Foo相同的名称， 通过<strong>转换</strong>或者强制<strong>多态化</strong>一个指向具体类型的指针来创建</p>
<p>特性也可以接受泛型参数。但更好的处理方式往往是使用<strong>关联类型</strong></p>
<pre><code class="language-Rust">//泛型参数
trait Graph&lt;N, E&gt; {
    fn has_edge(&amp;self, &amp;N, &amp;N) -&gt; bool;
    fn edges(&amp;self, &amp;N) -&gt; Vec&lt;E&gt;;
}

fn distance&lt;N, E, G: Graph&lt;N, E&gt;&gt;(graph: &amp;G, start: &amp;N, end: &amp;N) -&gt; u32 {

}

//关联类型
trait Graph {
    type N;
    type E;

    fn has_edge(&amp;self, &amp;Self::N, &amp;Self::N) -&gt; bool;
    fn edges(&amp;self, &amp;Self::N) -&gt; Vec&lt;Self::E&gt;;
}

fn distance&lt;G: Graph&gt;(graph: &amp;G, start: &amp;G::N, end: &amp;G::N) -&gt; uint {

}

struct Node;

struct Edge;

struct SimpleGraph;

impl Graph for SimpleGraph {
    type N = Node;
    type E = Edge;

    fn has_edge(&amp;self, n1: &amp;Node, n2: &amp;Node) -&gt; bool {

    }

    fn edges(&amp;self, n: &amp;Node) -&gt; Vec&lt;Edge&gt; {

    }
}

let graph = SimpleGraph;
let object = Box::new(graph) as Box&lt;Graph&lt;N=Node, E=Edge&gt;&gt;;
</code></pre>
<p>关于泛型我们会在<a href="https://www.wolai.com/nHJfi5qDQP2mKKANBASDTg">9.泛型</a>中详细讲解</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="28注释与文档"><a class="header" href="#28注释与文档">2.8.注释与文档</a></h1>
<h1 id="注释"><a class="header" href="#注释">注释</a></h1>
<p>Rust中有三种注释，前两种分别为：</p>
<ol>
<li>
<p>行注释 <code>//...</code></p>
</li>
<li>
<p>块注释 <code>/*...*/</code></p>
</li>
</ol>
<h1 id="文档"><a class="header" href="#文档">文档</a></h1>
<p>Rust的第三种注释是<strong>文档注释</strong>，文档注释有两种，支持<strong>MakeDown</strong>语法</p>
<ol>
<li>
<p><code>///</code>用来描述的它后面接着的项</p>
</li>
<li>
<p><code>//!</code>用来描述包含它的项，一般用在模块文件的头部</p>
</li>
</ol>
<h1 id="生成文档"><a class="header" href="#生成文档">生成文档</a></h1>
<p>Rust可以把文档注释导出为<strong>HTML</strong>格式：</p>
<ol>
<li>
<p><code>rustdoc *.rs</code></p>
</li>
<li>
<p><code>cargo doc</code></p>
</li>
</ol>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="29输入输出流"><a class="header" href="#29输入输出流">2.9.输入输出流</a></h1>
<p>输入输出流需要用到标准库中的内容，关于包与模块我们将在<a href="https://www.wolai.com/7PtSd1io4AxPY15qkcdNnT">14.模块和包</a>这一章中详细讲解</p>
<h1 id="控制台输入"><a class="header" href="#控制台输入">控制台输入</a></h1>
<pre><code class="language-Rust">use std::io;//导入IO库

fn read_input() -&gt; io::Result&lt;()&gt; {
    //创建空字符串
    let mut input = String::new();
    try!(io::stdin().read_line(&amp;mut input));
    println!(&quot;你输入了: {}&quot;, input.trim());
    Ok(())
}
fn main() {
    read_input();
}
</code></pre>
<p>因为读取可能会发生错误，所以本例中使用了<code>try!</code> 宏。这个宏会返回 <code>Result&lt;(), io::Error&gt;</code> 类型，所以需要单独使用一个 <code>read_input</code> 函数来接收这个类型，而不是在 <code>main</code> 函数里</p>
<pre><code class="language-Rust">use std::io;
fn main() {
    let mut input = String::new();

    io::stdin().read_line(&amp;mut input).unwrap();

    println!(&quot;You typed: {}&quot;, input.trim());
}
</code></pre>
<p>本例使用了 <code>Result&lt;(), io::Error&gt;</code> 类型的 <code>unwrap</code> 方法来接收 <code>io::stdin().read_line</code> 的返回类型。如果发生错误如果发生错误，则调用<code>panic</code>，更好的办法是使用<code>expect</code>方法，这个方法可以自定义返回内容</p>
<pre><code class="language-Rust">use std::io;
fn main() {
    let mut input = String::new();

    io::stdin().read_line(&amp;mut input).expect(&quot;错误&quot;);

    println!(&quot;You typed: {}&quot;, input.trim());
}
</code></pre>
<p>如果发生了错误，则返回<code>expect</code>中的内容并调用<code>panic</code></p>
<h1 id="控制台输出"><a class="header" href="#控制台输出">控制台输出</a></h1>
<p>Rust 里面常见的标准输出宏有 <code>print!</code> 和 <code>println!</code>。后者比前者在末尾多输出一个换行符</p>
<pre><code class="language-Rust">print!(&quot;这些文字&quot;);
print!(&quot;将被打印在同一行&quot;);

print!(&quot;这行文字用了转义字符来换行\n&quot;);

println!(&quot;还是这样直接换行方便&quot;); 
</code></pre>
<pre><code class="language-Rust">println!(&quot;这是rust的 {} 输出&quot;, &quot;格式化&quot;);
</code></pre>
<p>这里两个例子都比较简单。<code>{}</code> 会被 <code>&quot;格式化&quot;</code> 所替换。这是 rust 里面的一种格式化输出。</p>
<p>标准化的输出是<strong>行缓冲</strong>的,这就导致标准化的输出在遇到一个新行之前并不会被隐式刷新。 换句话说 <code>print!</code> 和 <code>println!</code> 二者的效果并不总是相同的。 比如：</p>
<pre><code class="language-Rust">use std::io;
fn main() {
    print!(&quot;请输入：&quot;);
    let mut input = String::new();
    io::stdin()
        .read_line(&amp;mut input)
        .expect(&quot;读取失败&quot;);
    print!(&quot;您输入的是：{}\n&quot;, input);
}
</code></pre>
<p>在这段代码运行时则不会先出现预期的提示字符串，因为行没有被刷新。 如果想要达到预期的效果就要显示的刷新，即在提示字符串下加入一行<code>io::stdout().flush().unwrap();</code></p>
<h1 id="文件输入"><a class="header" href="#文件输入">文件输入</a></h1>
<p>文件输入流指向了文件而不是控制台，一般通过match处理潜在错误</p>
<pre><code class="language-Rust">use std::error::Error;
use std::fs::File;
use std::io::prelude::*;
use std::path::Path;

fn main() {
    // 创建一个文件路径
    let path = Path::new(&quot;test.txt&quot;);
    let display = path.display();

    // 打开文件只读模式, 返回一个 `io::Result&lt;File&gt;` 类型
    let mut file = match File::open(&amp;path) {
        // 处理打开文件可能潜在的错误
        Err(err) =&gt; panic!(&quot;无法打开 {}，错误: {}&quot;, display,Error::description(&amp;err)),
        Ok(file) =&gt; file,
    };

    // 文件输入数据到字符串，并返回 `io::Result&lt;usize&gt;` 类型
    let mut s = String::new();
    match file.read_to_string(&amp;mut s) {
        Err(err) =&gt; panic!(&quot;无法读取 {}，错误: {}&quot;, display,Error::description(&amp;err)),
        Ok(_) =&gt; print!(&quot;{} 的内容为:\n{}&quot;, display, s),
    }
}
</code></pre>
<h1 id="文件输出"><a class="header" href="#文件输出">文件输出</a></h1>
<p>文件输出流重定向到文件中</p>
<pre><code class="language-Rust">static LOREM_IPSUM: &amp;'static str =&quot;输出文本&quot;;

use std::error::Error;
use std::io::prelude::*;
use std::fs::File;
use std::path::Path;

fn main() {
    let path = Path::new(&quot;out/test.txt&quot;);
    let display = path.display();

    // 用只写模式打开一个文件，并返回 `io::Result&lt;File&gt;` 类型
    let mut file = match File::create(&amp;path) {
        Err(err) =&gt; panic!(&quot;无法写入 {}，错误: {}&quot;,display,Error::description(&amp;err)),
        Ok(file) =&gt; file,
    };
</code></pre>
<hr />
<p>到这里，快速入门阶段就结束了，是时候通过更加系统的知识来熟悉读写 Rust 代码了。</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="基本程序结构"><a class="header" href="#基本程序结构">基本程序结构</a></h1>
<p>Rust 是多范式语言，当然支持命令式编程风格。本章讲解 Rust 中的几种基本程序结构，经过前面的粗略介绍，相信您在这里会有新的理解</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="41注释"><a class="header" href="#41注释">4.1.注释</a></h1>
<p>前面我们已经介绍过Rust的两种注释了。</p>
<p>Rust中有三种常见注释</p>
<ul>
<li>
<p>行注释</p>
</li>
<li>
<p>块注释</p>
</li>
<li>
<p>文档</p>
</li>
<li>
<p>文档注释</p>
</li>
<li>
<p>模块注释</p>
</li>
</ul>
<p>注释不会影响程序的运行</p>
<h1 id="行注释"><a class="header" href="#行注释">行注释</a></h1>
<p><code>//</code>后的，知道行尾，都属于行注释，</p>
<pre><code class="language-Rust">// 创建一个绑定
let x = 5;

let y = 6; // 创建另一个绑定
</code></pre>
<h1 id="块注释"><a class="header" href="#块注释">块注释</a></h1>
<p>这是C语言风格的注释</p>
<pre><code class="language-Rust">/*这是一段块注释*/let a = 1;/*块注释不影响块以外的代码*/
/*
块注释可以有很多行
*/ 
</code></pre>
<h1 id="文档注释"><a class="header" href="#文档注释">文档注释</a></h1>
<p>文档注释使用<code>///</code>，一般用于函数，结构体或枚举的说明，值域说明对象上方，支持<strong>makedown</strong>语法，可用<code>rustdoc</code>或<code>cargo doc</code>命令自动提取文档</p>
<pre><code class="language-Rust">/// 给数字加一
///
/// # 示例
///
/// ```
/// let one = 1;
///
/// assert_eq!(2, add_one(one));
/// # fn add_one(x: i32) -&gt; i32 {
/// #     x + 1
/// # }
/// ```
fn add_one(x: i32) -&gt; i32 {
    x + 1
}
</code></pre>
<h1 id="模块注释"><a class="header" href="#模块注释">模块注释</a></h1>
<p>模块注释使用<code>//!</code>,用于说明本模块的功能，一般位于模块顶</p>
<pre><code class="language-Rust">//! 这是一个模块
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="42条件分支语句"><a class="header" href="#42条件分支语句">4.2.条件分支语句</a></h1>
<ul>
<li>
<p>if</p>
</li>
<li>
<p>match</p>
</li>
<li>
<p>if let</p>
</li>
</ul>
<h1 id="if-1"><a class="header" href="#if-1">if</a></h1>
<p>在Rust中，<code>if</code>表达式基本形式如下</p>
<pre><code class="language-Rust">//形式1
if case1 {
  code
}

//形式2
if case2 {
  code
} else {
  code
}
 
//形式3
if case3 {
  code
} else if case4 {
  code //else if 可以有很多个
} else {
  code
}
</code></pre>
<p>可以看出Rust中的if不需要小括号把条件括起来。而且我们上面也说到了，if是一个表达式而不是语句，这也就是说if有返回值，所以我们可以有这样的代码</p>
<pre><code class="language-Rust">let a = 0;
let b = if a == 0 {
  0
} else {
  1
};//注意，因为let是一个语句，所以这里需要分号
//也可以写成一行，即
//let b = if a == 0 {0} else {1}; 
</code></pre>
<h1 id="match-1"><a class="header" href="#match-1">match</a></h1>
<p>当某个条件会有多个分支时，可能会出现大量的<code>else if</code>，为了应对这种情况，Rust提供了一个强大的匹配模式—<code>match</code></p>
<pre><code class="language-Rust">let a = 10;
match a {
  1=&gt;{
    print!(&quot;a is:&quot;);//分支可以是一个语句块
    print!(&quot;1&quot;);
  },
  2=&gt;println!(&quot;a is 2&quot;),//分支之间用，隔开
  _=&gt;println!(&quot;something else&quot;),
  //match会进行穷举性检查，必须包含所有可能的匹配项，当匹配项过多或我们只需要其中几个匹配项时，可以用通配符_来匹配所有剩余项
} 
</code></pre>
<p>match的功能远不止这些，以后的章节会慢慢讲到，match也是一个表达式。关于match会在<a href="https://www.wolai.com/cLgBuT752udmXPme8oBaTp">7.匹配模式</a>这一章专门论述。</p>
<h1 id="if-let"><a class="header" href="#if-let">if let</a></h1>
<p>有的时候，虽然一个条件有多个分支，但我们只关心其中几个，用match就显得有些繁琐了，这时就可以用match的简化用法—<code>if let</code>，直接上例子</p>
<pre><code class="language-Rust">let a = Some(1);

if let Some(b) = a {
    println!(&quot;{}&quot;, b);      // 这里输出为：5
}

let c = if let Some(b) = a {
    b
}
else {
    0
};
//以上等价于
 let a = Some(1);
match a {
    Some(b) =&gt; println!(&quot;{}&quot;, b),
    None =&gt; ()
}

let c = match a {
    Some(b) =&gt; b,
    None =&gt; 0
};
</code></pre>
<p>这个特性可以使条件判断的时候，直接做一次模式匹配，方便代码书写，使代码更紧凑</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="43循环语句"><a class="header" href="#43循环语句">4.3.循环语句</a></h1>
<ul>
<li>
<p>while</p>
</li>
<li>
<p>loop</p>
</li>
<li>
<p>for</p>
</li>
<li>
<p>break &amp; continue</p>
</li>
<li>
<p>label(标签)</p>
</li>
</ul>
<h1 id="while-1"><a class="header" href="#while-1">while</a></h1>
<p>关于循环，首先是大家熟悉的<code>while</code>循环，当条件为真时执行循环体，当您不确定应该循环几次时，您应该使用while</p>
<pre><code class="language-Rust">while expression {
  code
}
</code></pre>
<p>举一个简单的例子</p>
<pre><code class="language-Rust">let mut a = 1;
let mut exp = true;
while exp {
  a += 1;
  println!(&quot;{}&quot;,a);
  if a &gt; 5 {
    exp = false
  }
}
</code></pre>
<h1 id="loop-1"><a class="header" href="#loop-1">loop</a></h1>
<p>有的时候，我们可能需要一个无限循环，这时我们会很自然的想到<code>while true</code>，但我不推荐您这样用，Rust针对这种情况专门<strong>优化</strong>并提供了一个关键字，loop，即</p>
<pre><code class="language-Rust">loop {
  code
} 
</code></pre>
<p><code>loop</code> 与 <code>while true</code> 的主要区别在编译阶段的静态分析。这个微小的区别也会影响生命周期分析，所以如果需要用到无限循环，选择loop就对了</p>
<h1 id="for-1"><a class="header" href="#for-1">for</a></h1>
<p>有学过C的朋友可能会熟悉<code>for</code>的三元循环语句，就像这样</p>
<pre><code class="language-C">for (a = 0;a &lt; 10;a++) {
  printf(&quot;%d\n&quot;, x);
}
</code></pre>
<p>而在Rust中，for用于遍历一个迭代器。</p>
<pre><code class="language-Rust">for var in iterator {
  code
}
</code></pre>
<p>Rust 迭代器返回一系列的元素，每个元素是循环中的一次重复。然后它的值与 var 绑定，它在循环体中有效。每当循环体执行完后，我们从迭代器中取出下一个值，然后我们再重复一遍。当迭代器中不再有值时，for 循环结束退出，上面的C代码就等价于</p>
<pre><code class="language-Rust">for a in 0..10 {
  println!(&quot;{}&quot;,a);
}
</code></pre>
<p>这样的设计不仅可以减少运行时边界检查，提高效率，更是简化了边界条件确定，减少出错。比如如果你要用while来遍历一个数组，那你就不得不考虑边界问题，而for，就像是迭代器的一个语法糖。</p>
<p>for当然也可以返回元素的索引，只需要一个<code>.enumerate()</code>函数，比如</p>
<pre><code class="language-Rust">for (a,b) in (1..=3).enumerate() {
    println!(&quot;索引为{}的元素是{}&quot;, a, b);
}
</code></pre>
<p>输出</p>
<pre><code class="language-纯文本">索引为0的元素是1
索引为1的元素是2
索引为2的元素是3 
</code></pre>
<p>Rust中迭代器的索引是从0开始的</p>
<p>再举一个例子</p>
<pre><code class="language-Rust">let lines = &quot;第一行
第二行
第三行
第四行&quot;.lines();
for (linenumber, line) in lines.enumerate() {
    println!(&quot;{}: {}&quot;, linenumber, line);
}
</code></pre>
<h1 id="break--continue"><a class="header" href="#break--continue">break &amp; continue</a></h1>
<ul>
<li>
<p><code>break</code>用于<strong>跳出当前循环</strong></p>
</li>
<li>
<p><code>continue</code>用于<strong>结束本次循环</strong>并立即开始下一次循环</p>
</li>
</ul>
<p>while中的那个例子，可以优化为</p>
<pre><code class="language-Rust">let mut a = 1;
loop {
  a+=1;
  println!(&quot;{}&quot;,a);
  if a &gt; 5 {
    break;
  }
} 
</code></pre>
<p>下面是continue的例子，用于打印奇数</p>
<pre><code class="language-Rust">for a in 0..10 {
  if a % 2 == 0 {
    continue;
  }
  println!(&quot;{}&quot;,a);
}
</code></pre>
<p>众多循环语句都可以作为表达式，break和continue可用来提前返回一个值</p>
<pre><code class="language-Rust">let mut times = 0;
let a = loop {
  times+=1;
  if times == 10 {
    break times*2;
  }
}
</code></pre>
<h1 id="label"><a class="header" href="#label">label</a></h1>
<p>很多时候，我们会将循环嵌套使用，但break和continue默认对当前循环起作用，假如想在内循环跳出外循环，可以使用<strong>标签</strong></p>
<pre><code class="language-Rust">'outer loop {
  'inner for a in 1..3 {
    if a == 2{break 'outer}
    println!(&quot;{}&quot;,a);
  }
}
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="5类型运算符与字符串"><a class="header" href="#5类型运算符与字符串">5.类型、运算符与字符串</a></h1>
<p>本章讲解 Rust 中的类型相关基础知识、运算符相关知识和字符串的基本知识</p>
<p><a href="4_type_operator_string/5.1.%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%9E%8B/5.1.%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%9E%8B.html">5.1.原生类型</a></p>
<p><a href="4_type_operator_string/5.2.%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B/5.2.%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B.html">5.2.复合类型</a></p>
<p><a href="4_type_operator_string/5.3.%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B/5.3.%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B.html">5.3.字符串类型</a></p>
<p><a href="4_type_operator_string/5.4.%E5%9F%BA%E7%A1%80%E8%BF%90%E7%AE%97%E7%AC%A6/5.4.%E5%9F%BA%E7%A1%80%E8%BF%90%E7%AE%97%E7%AC%A6.html">5.4.基础运算符</a></p>
<p><a href="4_type_operator_string/5.5.%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A0%BC%E5%BC%8F%E5%8C%96/5.5.%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A0%BC%E5%BC%8F%E5%8C%96.html">5.5.字符串格式化</a></p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="51原生类型"><a class="header" href="#51原生类型">5.1.原生类型</a></h1>
<p>作为一种系统级编程语言，Rust提供了一系列基础的类型，我们一般称之为原生类型。其强大的类型系统就是建立在这些原生类型之上的。下面就让我们来学习这些原生类型</p>
<h1 id="bool"><a class="header" href="#bool">bool</a></h1>
<h1 id="char"><a class="header" href="#char">char</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
